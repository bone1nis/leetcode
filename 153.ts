/*
153. Найти минимум в повернутом отсортированном массиве
Попытка
Середина
Темы
Компании
Намекать
Предположим, что массив длины n, отсортированный в порядке возрастания, вращается между 1и nраз. Например, массив nums = [0,1,2,4,5,6,7]может стать:

[4,5,6,7,0,1,2]если бы он был повернут 4раз.
[0,1,2,4,5,6,7]если бы он был повернут 7раз.
Обратите внимание, что вращение массива [a[0], a[1], a[2], ..., a[n-1]]1 раз приводит к получению массива [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Учитывая отсортированный повернутый массив numsуникальных элементов , вернуть минимальный элемент этого массива .

Вам необходимо написать алгоритм, работающий в  O(log n) time.

 

Пример 1:

Ввод: nums = [3,4,5,1,2]
 Вывод: 1
 Пояснение: Исходный массив был повернут на [1,2,3,4,5] 3 раза.
Пример 2:

Ввод: nums = [4,5,6,7,0,1,2]
 Вывод: 0
 Пояснение: Исходный массив был [0,1,2,4,5,6,7], и он был повернут 4 раза.
Пример 3:

Ввод: nums = [11,13,15,17]
 Вывод: 11
 Пояснение: Исходный массив был [11,13,15,17], и он был повернут 4 раза. 
 

Ограничения:

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
Все целые числа numsуникальны .
numsсортируется и вращается между 1и nраз.
*/


// v1

function findMin(nums: number[]): number {
    return Math.min(...nums);
};

// v2

function findMin(nums: number[]): number {
    let left = 0;
    let right = nums.length - 1;


    while (left <= right) {
        const middle = Math.floor((left + right) / 2);

        if (middle < nums.length - 1 && nums[middle] > nums[middle + 1]) return nums[middle + 1];
        if (middle > 0 && nums[middle] < nums[middle - 1]) return nums[middle];

        if (nums[middle] > nums[right]) left = middle + 1;
        else right = middle - 1;
    }

    return nums[0];
};