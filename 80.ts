/* 
80. Удалить дубликаты из отсортированного массива II
Решено
Середина
Темы
Компании
Дан целочисленный массив, numsотсортированный в неубывающем порядке , удалить некоторые дубликаты на месте так, чтобы каждый уникальный элемент встречался не более двух раз . Относительный порядок элементов должен оставаться прежним .

Поскольку в некоторых языках невозможно изменить длину массива, вместо этого вы должны поместить результат в первую часть массива nums. Более формально, если есть kэлементы после удаления дубликатов, то первые kэлементы nums должны содержать конечный результат. Неважно, что вы оставляете после первых  k элементов.

Возврат kпосле размещения окончательного результата в первых kслотахnums .

Не выделяйте дополнительное пространство для другого массива. Вы должны сделать это, изменив входной массив на месте с O(1) дополнительной памяти.

Судья по индивидуальному заказу:

Судья проверит ваше решение с помощью следующего кода:

int[] nums = [...]; // Входной массив 
int[] expectedNums = [...]; // Ожидаемый ответ с правильной длиной 

int k = removeDuplicates(nums); // Вызывает вашу реализацию 

assert k == expectedNums.length; 
for (int i = 0; i < k; i++) { 
    assert nums[i] == expectedNums[i]; 
}
Если все утверждения пройдены, то ваше решение будет принято .

 

Пример 1:

Ввод: nums = [1,1,1,2,2,3]
 Вывод: 5, nums = [1,1,2,2,3,_]
 Пояснение: Ваша функция должна возвращать k = 5, где первые пять элементов nums будут 1, 1, 2, 2 и 3 соответственно. 
Неважно, что вы оставите после возвращаемого k (следовательно, это подчеркивания).
Пример 2:

Вход: nums = [0,0,1,1,1,1,2,3,3]
 Выход: 7, nums = [0,0,1,1,2,3,3,_,_]
 Пояснение: Ваша функция должна вернуть k = 7, где первые семь элементов nums будут 0, 0, 1, 1, 2, 3 и 3 соответственно. 
Неважно, что вы оставите после возвращаемого k (следовательно, это подчеркивания).
 

Ограничения:

1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
numsсортируется в неубывающем порядке. */


function removeDuplicates(nums: number[]) {
    let arr: number[] = [];

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== nums[i + 2]) {
            arr.push(nums[i])
        }
    }

    for (let i = 0; i < nums.length; i++) { // вместо этого можно юзать nums = [...arr], но литкод почему-то не принимал, хотя у меня все работало
        nums[i] = arr[i]
    }

    return arr.length;
};


// v2

function removeDuplicates(nums: number[]): number {
    let count = 0, current = 1;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] !== nums[i - 1]) {
            count = 0;
            nums[current++] = nums[i]
        } else {
            count++;
            if (count <= 1) nums[current++] = nums[i];
        }
    }

    return current;
}